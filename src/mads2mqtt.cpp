/*
  __  __  ___ _____ _____         _             _       
 |  \/  |/ _ \_   _|_   _|  _ __ | |_   _  __ _(_)_ __  
 | |\/| | | | || |   | |   | '_ \| | | | |/ _` | | '_ \ 
 | |  | | |_| || |   | |   | |_) | | |_| | (_| | | | | |
 |_|  |_|\__\_\|_|   |_|   | .__/|_|\__,_|\__, |_|_| |_|
                           |_|            |___/         
# A Template for Mqtt2madsPlugin, a Source Plugin
# Generated by the command: plugin -t source -d mqtt_plugin mqtt2mads
# Hostname: Fram-IV.local
# Current working directory: /Users/p4010/Develop/MADS_plugins
# Creation date: 2024-08-01T12:22:33.802+0200
# NOTICE: MADS Version 1.0.1
*/
// Mandatory included headers
#include <sink.hpp>
#include <nlohmann/json.hpp>
#include <pugg/Kernel.h>
// other includes as needed here
#include <mosquittopp.h>
#include <thread>
#include <csignal>

// Define the name of the plugin
#ifndef PLUGIN_NAME
#define PLUGIN_NAME "mads2mqtt"
#endif
#define NO_ERROR "No Error"

// Load the namespaces
using namespace std;
using json = nlohmann::json;
using namespace mosqpp;



// Plugin class. This shall be the only part that needs to be modified,
// implementing the actual functionality
class Mads2mqttPlugin : public Sink<json>, public mosquittopp {

public:

  // Typically, no need to change this
  string kind() override { return PLUGIN_NAME; }

/*
  __  __  ___ _____ _____            _       _           _ 
 |  \/  |/ _ \_   _|_   _|  _ __ ___| | __ _| |_ ___  __| |
 | |\/| | | | || |   | |   | '__/ _ \ |/ _` | __/ _ \/ _` |
 | |  | | |_| || |   | |   | | |  __/ | (_| | ||  __/ (_| |
 |_|  |_|\__\_\|_|   |_|   |_|  \___|_|\__,_|\__\___|\__,_|
                                                           
*/

  return_type setup() {
    return_type status = return_type::success;
    if (_connected) return status;
    string host = _params["broker_host"];
    string topic = _params["topic"];
    int port = _params["broker_port"];

    lib_init();
    reinitialise("MADS2MQTT-bridge", true);
    loop_start();
    if (connect_async(host.c_str(), port, 5) != MOSQ_ERR_SUCCESS) {
      cerr << "Failed to connect to MQTT broker" << endl;
      status = return_type::critical;
    } 
    return status;
  }

  ~Mads2mqttPlugin() {
    disconnect();
    mosqpp::lib_cleanup();
  }

  void on_connect(int rc) override {
    if (!_params["silent"])
      cerr << "Connected with code " << rc << endl;
    _connected = true;
    return;
  }

  void on_disconnect(int rc) override {
    if (!_params["silent"])
      cerr << "Disconnected with code " << rc << endl;
    _connected = false;
    return;
  }


/*
  ____  _    _   _  ____ ___ _   _ 
 |  _ \| |  | | | |/ ___|_ _| \ | |
 | |_) | |  | | | | |  _ | ||  \| |
 |  __/| |__| |_| | |_| || || |\  |
 |_|   |_____\___/ \____|___|_| \_|
                                   
*/

  return_type load_data(json const &input, string topic = "") override {
    if (!_connected) {
      reconnect_async();
      while (!_connected) {
        this_thread::sleep_for(chrono::milliseconds(100));
      }
    }
    json jpl;
    jpl["mads_topic"] = topic;
    jpl["payload"] = input;
    int mid = 0;
    string payload;
    try {
      payload = jpl.dump();
    } catch (const std::exception &e) {
      cerr << "Error serializing JSON: " << e.what() << endl;
      return return_type::error;
    }
    if (!_params["silent"]) {
      cerr << "Publishing " << payload << " to topic " << topic << endl;
    }
    int rv = publish(&mid, _params["topic"].get<string>().c_str(), payload.size(), payload.c_str(), _params["QoS"], false);

    if (rv != MOSQ_ERR_SUCCESS) {
      cerr << "Error publishing MQTT message: " << mosqpp::strerror(rv) << endl;
      return return_type::error;
    }
    return return_type::success;
  }

  void set_params(void const *params) override {
    Sink::set_params(params);
    _params["broker_host"] = "localhost";
    _params["broker_port"] = 1883;
    _params["silent"] = true;
    _params["QoS"] = 0;
    _params["topic"] = "mads";
    _params.merge_patch(*(json *)params);
    setup();
    while (!_connected) {
      this_thread::sleep_for(chrono::milliseconds(100));
    }
  }

  map<string, string> info() override {
    return {
      {"Broker:", _params["broker_host"].get<string>() + ":" + to_string(_params["broker_port"])},
      {"Topic:", _params.value("topic", "mads")},
      {"QoS: ", to_string(_params["QoS"].get<int>())},
      {"Silent:", _params["silent"] ? "true" : "false"}
    };
  };

private:
  json _data;
  string _topic;
  bool _connected = false;
};


/*
  ____  _             _             _      _
 |  _ \| |_   _  __ _(_)_ __     __| |_ __(_)_   _____ _ __
 | |_) | | | | |/ _` | | '_ \   / _` | '__| \ \ / / _ \ '__|
 |  __/| | |_| | (_| | | | | | | (_| | |  | |\ V /  __/ |
 |_|   |_|\__,_|\__, |_|_| |_|  \__,_|_|  |_| \_/ \___|_|
                |___/
Enable the class as plugin
*/
INSTALL_SINK_DRIVER(Mads2mqttPlugin, json)


/*
                  _
  _ __ ___   __ _(_)_ __
 | '_ ` _ \ / _` | | '_ \
 | | | | | | (_| | | | | |
 |_| |_| |_|\__,_|_|_| |_|

For testing purposes, when directly executing the plugin
*/
static bool running = true;

int main(int argc, char const *argv[]) {
  Mads2mqttPlugin plugin;
  json output, params;

  params["broker_host"] = "localhost";
  params["broker_port"] = 1883;
  params["topic"] = "mads";
  params["silent"] = false;
  params["QoS"] = 0;

  if (argc >= 2) {
    params["broker_host"] = argv[1];
  }

  if (argc >= 3) {
    params["broker_port"] = atoi(argv[2]);
  }

  // Set parameters
  plugin.set_params(&params);

  signal(SIGINT, [](int s) {
    cout << "Interrupted" << endl;
    running = false;
  });

  // Process data
  string line = "";
  while (running) {
    getline(cin, line);
    if (!line.empty()) {
      json message;
      try {
        message = json::parse(line);
      } catch (const std::exception &e) {
        cerr << "Error parsing JSON: " << e.what() << endl;
        continue;
      }
      auto rt = plugin.load_data(message);
      if (rt != return_type::success) {
        cerr << "Failed to load data" << endl;
      }
    } else {
      cerr << "Empty input line" << endl;
      break;
    }
  }
  
  return 0;
}
